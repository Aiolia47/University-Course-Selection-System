# 错误处理策略

## 错误流

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Gateway as API网关
    participant Service as 业务服务
    participant ErrorHandler as 错误处理器
    participant Logger as 日志服务
    participant Monitor as 监控服务

    Client->>Gateway: API请求
    Gateway->>Service: 转发请求

    alt 业务逻辑错误
        Service->>ErrorHandler: 抛出业务错误
        ErrorHandler->>Logger: 记录错误日志
        ErrorHandler->>Monitor: 发送错误指标
        ErrorHandler-->>Gateway: 格式化错误响应
        Gateway-->>Client: 错误响应
    else 系统错误
        Service->>ErrorHandler: 抛出系统错误
        ErrorHandler->>Logger: 记录错误堆栈
        ErrorHandler->>Monitor: 触发告警
        ErrorHandler-->>Gateway: 通用错误响应
        Gateway-->>Client: 500错误响应
    end
```

## 错误响应格式

```typescript
interface ApiError {
  error: {
    code: string;
    message: string;
    details?: Record<string, any>;
    timestamp: string;
    requestId: string;
  };
}
```

## 前端错误处理

```typescript
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface ErrorState {
  currentError: ApiError | null;
  errorHistory: ApiError[];
}

const errorSlice = createSlice({
  name: 'error',
  initialState: {
    currentError: null,
    errorHistory: [],
  } as ErrorState,
  reducers: {
    setError: (state, action: PayloadAction<ApiError>) => {
      state.currentError = action.payload;
      state.errorHistory.push(action.payload);

      // 只保留最近50个错误
      if (state.errorHistory.length > 50) {
        state.errorHistory.shift();
      }
    },
    clearError: (state) => {
      state.currentError = null;
    },
  },
});

export const { setError, clearError } = errorSlice.actions;
```

## 后端错误处理

```typescript
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { ApiResponse } from '../utils/response';

export interface AppError extends Error {
  statusCode: number;
  code: string;
  details?: Record<string, any>;
  isOperational: boolean;
}

export class CustomError extends Error implements AppError {
  statusCode: number;
  code: string;
  details?: Record<string, any>;
  isOperational: boolean;

  constructor(message: string, statusCode: number, code: string, details?: Record<string, any>) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export const errorHandler = (
  error: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  let { statusCode = 500, message, code = 'INTERNAL_ERROR', details } = error;

  // 记录错误日志
  logger.error({
    message: error.message,
    stack: error.stack,
    code,
    details,
    requestId: req.headers['x-request-id'],
    method: req.method,
    url: req.url,
    userAgent: req.headers['user-agent'],
    ip: req.ip,
  });

  // 开发环境返回堆栈信息
  if (process.env.NODE_ENV === 'development') {
    details = { ...details, stack: error.stack };
  }

  // 返回标准错误响应
  return ApiResponse.error(res, code, message, statusCode, details);
};

export const notFoundHandler = (req: Request, res: Response) => {
  return ApiResponse.notFound(res, '请求的资源不存在');
};
```
